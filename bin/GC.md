 취업준비를 하면서 내가 제대로 보지 못했던 자바의 '진짜 모습'을 보고자 노력하고 있다. 그래서 첫번째로, GC에대해서 살펴 볼 것이다.

자바를 공부하면서 흥미로웠던 것은 GC였다. 하지만, 학교내의 프로젝트에서는 GC를 보기 힘들다. 이번기회를 통해 GC를 튜닝하는 방법까지 공부하면서 구현할 예정이다.  

**가비지 컬렉션(GC)** 

말그대로 '쓰레기 수집가'이다. 하지만 그냥 수집가가 아니다, GC는 프로그램의 성능과도 연결될 수 있다. 그만큼 GC는 자바의 필수적인 요소이다. 

**Stop-the-world**

이 용어의 뜻은 나는 이렇게 이해했다. 모두 멈추고 어둠의 지배자인 GC의 활동(?).. 이해하기 위해서 이렇게 생각했었다.  GC를 진행하는 쓰레드를 제외하고 모든 쓰레드가 멈춘후, GC가 작업을 완료하면 중단한 작업들을 다시 시작한다, 라는 용어이다. 생각해보면 멈춘시간이 짧을 수록 좋은 프로그램이 아닐까 생각든다. 그렇기때문에 GC튜닝과정에서는 이 시간을 줄이는 것이다.

**자바는 명시적으로 프로그램을 지정하여 해제 하지 않는다**

그렇다. 그러지 않는다, 명시적으로 해제하지 않고 가비지 컬렉터가 필요없는 객체들을 찾아 치우는 작업을 한다. 하고 싶다면 null로 지정하거나, system.gc()를 호출하는데 후자는 절대로 하면 안된다.(성능에 무리)

**weak generational hypothesis**

가비지 컬렉터는 이 가설을 바탕으로 만들어 졌는데 , 

- 대부분의 객체는 금방 접근 불가능상태가 된다.
- 오래된 객체에서 젊은 객체로의 참조는 아주 적다.

이 가설을 전제조건으로 가비지 콜렉터가 만들어졌다.

**2개의 공간 Young and Old**

위 가설의 장점을 살리기 위해 2개의 물리적 공간으로 나뉘는데 , 

**Young**과 **Old**이다.

<u>Young 영역</u> 

-  새롭게 생성한 객체들이 이곳에 저장된다.
- 객체가 접근 불가능한 상태이므로 생성과 소멸의 과정을 거친다.
- 소멸의 과정에서 *Minor GC*가 발생한다. 

<u>Order 영역</u>

- 접근불가 구역이 아니다. 그래서 Young영역에서 살아남은 객체가 이곳으로 복사된다.
- 위의 사항에 대한 특징상 Young영역보다 크기가 커야된다.
- Young영역보다는 GC횟수가 비교적 적다.
- 소멸의 과정에서 *Major GC(Full GC)*가 발생한다.



```
      
추가적으로 perm영역이 있다. java 8에서는 사라졌다고 들었다, 아니 대체되었다는 표현이 정확하겠다. 이 영역에서는 객체or억류된 문자열이 저장된다. Old영역에서 살아남은 객체가 영원히 남아있는 것은 아니다. GC가 발생할 수 있고 Major GC라한다.

```



**Old영역에 있는 객체가 Young 영역의 객체를 참조하는 경우의 처리**

**카드 테이블**을 이용한다. 카드테이블의 크기는 512Byte이다. Old영역에 있는 객체가 Young영역의 객체를 참조할때마다 카드테이블에 표시를 해준다. 따라서 Young의 GC가 실행되면 Old영역이 아닌 카드테이블을 이용하여 처리한다. write barrier를 사용하며 관리하고 minor gc빠르게 해준다. 약간의 오버헤드의 위험이 있지만, 전반적인 GC시간은 줄어든다. 



—추가 업로드 예정